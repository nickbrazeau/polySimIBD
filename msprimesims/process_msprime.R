
# process_msprime.R
#
# Author: Bob Verity
# Date: 2019-09-24
#
# Purpose:
# read in msprime data (generated by Nick) and process to extract coalescence
# times at defined loci. Write processed data to file
#
# ------------------------------------------------------------------

# load bobfunctions2 package. If not already installed this can be obtained from
# Github via the command devtools::install_github('bobverity/bobfunctions2')
library(bobfunctions2)


# cleanup and process raw msprime style dataframe
process_msprime <- function(dat_raw) {
  
  # fix data types
  dat_raw$simnum <- as.numeric(dat_raw$simnum)
  dat_raw$smplsize <- as.numeric(as.character(dat_raw$smplsize))
  
  # extract interval start and end
  interval_start_end <- mapply(function(x) {
    as.numeric(strsplit(x, split = "\\(|\\)|\\,")[[1]][2:3])
  }, dat_raw$interval)
  
  # append interval to raw data
  dat_raw$interval0 <- interval_start_end[1,]
  dat_raw$interval1 <- interval_start_end[2,]
  
  # return
  return(dat_raw)
}


# extract coalescent times at every locus from msprime style dataframe
msprime_to_coal <- function(dat_raw, pos) {
  
  # extract sample size (n)
  n <- dat_raw$smplsize[1]
  
  # extract coalescent times of all sims
  ret <- mapply(function(i) {
    
    # subset to this sim
    dat_sub_sim <- subset(dat_raw, simnum == i)
    
    # extract times for every interval in this sim
    t_mat <- t(mapply(function(j) {
      
      # subset to this tree
      dat_sub_tree <- subset(dat_sub_sim, treeindex == j)
      
      # extract times
      w <- which(!dat_sub_tree$node %in% 0:(n-1))
      internal <- dat_sub_tree$node[w]
      m <- match(dat_sub_tree$nodeparent, internal)
      t <- sort(rep(dat_sub_tree$time2parent[w], times = tabulate(m) - 1))
      
      # append interval information and return
      ret <- c(interval0 = dat_sub_tree$interval0[1],
              t = t)
      return(ret)
      
    }, unique(dat_sub_sim$treeindex)))
    
    # convert to coalescent time per locus
    ret <- t_mat[findInterval(pos, t_mat[,1]), -1, drop = FALSE]
    
    return(ret)
    
  }, unique(dat_raw$simnum), SIMPLIFY = FALSE)
  
  # return list
  return(ret)
}


# loop through parameter combinations and get coalescent times into nested list
get_output <- function(dat_raw, pos, model_vec, smplsize_vec) {
  
  # loop through parameter combinations
  out_list <- list()
  for (i in 1:length(model_vec)) {
    out_list[[i]] <- list()
    for (j in 1:length(smplsize_vec)) {
      
      # subset data
      dat_sub <- subset(dat_raw, model == model_vec[i] & smplsize == smplsize_vec[j])
      
      # extract coalescent times
      coal_list <- msprime_to_coal(dat_raw = dat_sub,
                                   pos = pos)
      
      # save to list
      out_list[[i]][[j]] <- coal_list
      
    }
    names(out_list[[i]]) <- smplsize_vec
  }
  names(out_list) <- model_vec
  
  # return
  return(out_list)
}

# ------------------------------------------------------------------

# load raw data
dat_raw_v1 <- readRDS("data/msprimesims_v1.rds")
dat_raw_v2 <- readRDS("data/msprimesims_v2.rds")

# cleanup and process
dat_v1 <- process_msprime(dat_raw_v1)
dat_v2 <- process_msprime(dat_raw_v2)

# define parameters
pos <- seq(0, 1000, 1)
model_vec <- c("discrete wright fisher", "smc", "smcprime")
smplsize_vec <- c(2,3,5)

# loop through parameter combinations and get coalescent times
output_v1 <- get_output(dat_raw = dat_v1,
                        pos = pos,
                        model_vec = model_vec,
                        smplsize_vec = smplsize_vec)
output_v2 <- get_output(dat_raw = dat_v2,
                        pos = pos,
                        model_vec = model_vec,
                        smplsize_vec = smplsize_vec)

# save output
saveRDS(output_v1, "output/msprimesims_v1_processed.rds")
saveRDS(output_v2, "output/msprimesims_v2_processed.rds")

