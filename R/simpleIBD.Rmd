---
title: "..."
author: "Nicholas F. Brazeau"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    highlight: textmate
    theme: lumen
    toc: no
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Justification
Simple model because don't want to deal with levels of IBD

### Functions
```{r function}

#' @title Simulate data ...todo...
#'
#' @description Simulate a population of samples from an pop AF distribution
#'
#' @param pos numeric vector; genomic coordinates
#' @param nsamps integer; number of samples
#' @param p_shape1 integer; alpha in beta dist
#' @param p_shape2 integer; beta in beta dist
#' @param propMissing integer; prob of missingness per sample 
#'
#' @export

simPopData <- function(pos=c(sort(sample(1e5, 1e2))),
                    nsamps = 2, 
                    p = NULL,
                    p_shape1 = 0.1,
                    p_shape2 = 0.1,
                    propMissing = 0) {

  
  n <- length(pos)
  # if p=NULL then simulate frequency of the REF allele at each locus in each contig
  if (is.null(p)) {
   p <- rbeta(n, p_shape1, p_shape2)
  }


  # initialise objects
  CHROMPOS <- data.frame(CHROM = "contig1", POS = pos)
  genmat <- matrix(NA, nrow = length(pos), ncol = nsamps)
  
  genmat <- apply(genmat, 2, 
                  function(x){return(2*rbinom(n = n, size = 1, prob = 1 - p))})
  
  colnames(genmat) <- paste0("smp", 1:ncol(genmat))
  genmat <- cbind.data.frame(CHROMPOS, genmat)

  # missing data
  if (propMissing > 0) {
    for(i in 2:ncol(genmat)){
      genmat[sample(1:sum(n), round(sum(n)*propMissing)), i] <- -1
    }
  }
  ret <- list(paf = p,
              genmat = genmat)
  return(ret)
  
}



#' @title Simulate IBD sections between two samples under the hmmIBD model
#'
#' @description Walks along a vector of genomic locations and swiches between two states that represent IBD and non-IBD using a Markov model. The parameters that dictate the chance of switching state at any point include the average level of relatedness (\code{f}), the physical distance between loci in units of base pairs (from \code{pos}), and the recombination rate (\code{rho}), which is assumed constant over all loci.
#'
#' @param smpl1 numeric vector; haplotype vector 
#' @param smpl2 numeric vector; haplotype vector 
#' @param f the average relatedness between the two samples
#' @param rho the recombination rate
#' @param k the number of generations separating the two lineages
#' @param pos the genomic positions of the sites of interest
#'
#' @export

simIBD <- function(smpl1, smpl2, f, k, rho, pos) {

  # draw starting state
  n <- length(pos) # abs number of loci, not pos -- this is consistent with simData below
  ret <- rep(NA, n)
  ret[1] <- sample( c(0,1), size = 1, prob = c(1-f,f) )

  # draw subsequent states
  for (i in 2:n) {
    d <- pos[i]-pos[i-1]
    if (ret[i-1] == 0) {    # move from non-IBD state to non-IBD is t11
      t11 <- 1 - f*( 1 - exp( -k*rho*d ) )
      ret[i] <- sample( c(0,1), size = 1, prob = c(t11, 1 - t11) )
    } else {  # move from IBD state to IBD is t22
      t22 <- 1 - (1 - f)*( 1 - exp( -k*rho*d ) )
      ret[i] <- sample( c(0,1), size = 1, prob = c(1 - t22, t22) )
    }
  }

  smpl1[ret == 1] <- smpl2[ret == 1]
  
  out <- list(
    simIBDvector = ret,
    smpl1 = smpl1,
    smpl2 = smpl2
  )
  return(out)
}




```





#### Simulate "Base" Population
First simulate a population of haploid samples using independent draws from a population allele frequency distribution. 
```{r}

dat <- simPopData(pos = c(sort(sample(1e5, 1e2))),
                  nsamps = 5,
                  p_shape1 = 0.1,
                  p_shape2 = 0.1,
                  propMissing = 0)

```

#### Make Samples IBD
Then make two samples IBD under the `hmmIBD` model framework. Presumambly, you want to keep this in your population but you could go elsewhere...
```{r}

simIBD.dat <- simIBD(smpl1 = dat$genmat$smp1, 
                     smpl2 = dat$genmat$smp3,
                     pos = dat$genmat$POS,
                     f = 0.5, k = 1, rho = 1e-5) 

```

#### Make Mixtures --> simVCF
```{r}

#' @title make mixture
#'
#' @description Make mixture from list of samples
#'
#' @param strains list; 
#' @param strains.prop list;
#' @param pos numeric vector; genomic coordinates
#' @param dp numeric; read depth
#'
#' @export

#TODO add sample name
make_mixture <- function(strains = list(), strains.prop = list(),
                         pos, dp){
  
  if(length(strains) != length(strains.prop)){
    stop("strains and strain proportions must be of same length")
  }
  

  strains.mat <- unname(cbind.data.frame(strains))
  gt <- apply(strains.mat, 1, function(x){
    samp <- sample(x, dp, prob = unlist(strains.prop), replace = T)
    refad <- sum(unlist(samp) == 0)
    altad <- sum(unlist(samp) == 2)
    return( paste0("./.:", refad, ",", altad, ":", dp) ) # for now keep GT blank
  })
  
  gt <- cbind(FORMAT = "GT:AD:DP", gt)
  
  fix <- as.matrix(data.frame(CHROM = "contig1", POS = pos,
                              ID = ".", REF = ".", ALT = ".", QUAL = ".", FILTER = ".", INFO = "."))
  
  meta <- append("##fileformat=VCFv4.3", 
                 "##SimpleSim=This vcf was created using the simpleIBD approach")
  
    # write out new vcfRobj
  newvcfR <- new("vcfR", meta = meta, fix = fix, gt = gt)
  return(newvcfR)

  }
 


# TODO merge vcf function -- just cbind (make sure to keep names) the gt sinces we have same pos


```

##### Convert simVCFs to MIPanalyzer Object
```{r}
remotes::install_github("mrc-ide/MIPanalyzer")
library(MIPanalyzer)

MIPanalyzer::vcf2mipanalyzer_biallelic


```




